



30-java:{
	110-jvm:{
		parameter:{
			-Djava.awt.headless=true:{
				1. 	什么是Headless mode？ Headless模式是系统的一种配置模式。在该模式下，系统缺少了显示设备、键盘或鼠标。
				2. 	何时使用和headless mode？Headless模式虽然不是我们愿意见到的，但事实上我们却常常需要在该模式下工作，尤其是服务器端程序开发者。
					因为服务器（如提供Web服务的主机）往往可能"缺少"前述设备，但又需要"使用"他们提供的功能，生成相应的数据，以提供给客户端（如浏览器所在的配有相关的显示设备、键盘和鼠标的主机）。
				3.	如何使用和Headless mode？一般是在程序开始激活headless模式，告诉程序，现在你要工作在Headless mode下，就不要指望硬件帮忙了，你得自力更生，依靠系统的计算能力模拟出这些特性来:发布于 2020-06-11
				
				4. 测试程序：
				5. Toolkit类的getDefaultToolkit 函数 api中文说明
					public static Toolkit  getDefaultToolkit ()获取默认工具包。如果名为 "java.awt.headless" 的系统属性被设置为 true，则使用 Toolkit 的 headless 实现。如果不存在 "java.awt.headless" 或 "java.awt.headless" 被设置为 false，且存在名为 "awt.toolkit" 的系统属性，则该属性将被视为 Toolkit 子类的名称；否则将使用特定于平台的默认 Toolkit 实现。还可以使用 Sun 引用实现中指定的属性 'assistive_technologies' 将其他类加载到 VM 中，该属性是在 'accessibility.properties' 文件的一个行中指定的。形式是 "assistive_technologies=..."，其中 "..." 是以逗号分隔的、要加载的辅助技术类的列表。每个类都以给定的顺序加载，并且要使用 Class.forName(class).newInstance() 创建每个类的单独实例。此操作在创建 AWT 工具包之后进行。所有错误都通过 AWTError 异常来处理。  返回： 默认工具包。  抛出： AWTError - 如果不能找到 工具包 ，或者不能访问或实例化工具包。
				
				ref,	https://blog.idrsolutions.com/2013/08/what-is-headless-mode-in-java/
			}
		}
	},
	130-grammar:{
		Class:{
			Class.getName()：以String的形式，返回Class对象的“实体”名称；{
				com.se7n.test.Main
			},
			Class.getSimpleName()：获取源代码中给出的“底层类”简称。:{
				Main
			}
		},
		p21_file_xls:{
			jxl-小:{
				<dependency>
					<groupId>net.sourceforge.jexcelapi</groupId>
					<artifactId>jxl</artifactId>
					<version>2.6.12</version>
				</dependency>
			},
			poi-大:{
				<dependency>
					<groupId>org.apache.poi</groupId>
					<artifactId>poi</artifactId>
					<version>4.1.0</version>
				</dependency>
			}
		},
		p41_http:{
			
		}
	},
	302-deploy-nacos:{
		concept:{
			https://www.jianshu.com/p/39ade28c150d
			Dynamic Naming and Configuration Service	
			Na为naming/nameServer即注册中心,co为configuration即注册中心,service是指该注册/配置中心都是以服务为核心,服务在nacos是一等公民;
			Nacos服务领域模型主要分为命名空间、集群、服务。
			在下图的分级存储模型可以看到，
				在服务级别，保存了健康检查开关、元数据、路由机制、保护阈值等设置，
				而集群保存了健康检查模式、元数据、同步机制等数据，
				实例保存了该实例的ip、端口、权重、健康检查状态、下线状态、元数据、响应时间
			5/15/30 秒
		},
		history:{
			2.0.0-bugfix (Mar 30th, 2021),
			1.4.1 (Jan 15, 2021),
			1.4.0 (Nov 2, 2020),
			1.3.2 (Aug 4, 2020),
			1.2.1 (Mar 31th, 2020),
			1.1.4 (Oct 24th, 2019),
			1.1.0 (Jul 6th, 2019) Not recommended-'190706-1.1.0':{
				灰度配置、地址服务器模式、配置文件导入导出
			},
			1.0.1 (Jun 12, 2019)
			
		},
		design:{
						主动轮训(发现)		注册							注册		主动轮训(发现)	
			provider		<―― 			――>			Server				<―― 			――>			consumer	

			服务消费者nacos-consumer通过主动轮询获取他所订阅消费的服务信息列表;
			nacos-consumer根据获取到的服务信息列表，进行服务调用。
			
		},
		ow:{
			快速开始:{
				Nacos:{
					startup.sh -m standalone
					http://192.168.137.1:8848/nacos/index.html#/login		nacos/nacos
					curl -X POST "http://127.0.0.1:8848/nacos/v1/ns/instance?serviceName=nacos.naming.serviceName&ip=20.18.7.10&port=8080"
					curl -X GET "http://127.0.0.1:8848/nacos/v1/ns/instance/list?serviceName=nacos.naming.serviceName"
					curl -X POST "http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&group=test&content=HelloWorld"
					curl -X GET "http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&group=test"
				},
				Nacos Spring:{
					启动配置管理:{
						1. 添加依赖:{
							<dependency>
								<groupId>com.alibaba.nacos</groupId>
								<artifactId>nacos-spring-context</artifactId>
								<version>${latest.version}</version>
							</dependency>
						}
					}
					启动服务发现:{
						1. 添加依赖:{
							<dependency>
								<groupId>com.alibaba.nacos</groupId>
								<artifactId>nacos-spring-context</artifactId>
								<version>${latest.version}</version>
							</dependency>
						}
					}
				}
			}
		},
		延伸阅读:{
				https://www.oschina.net/p/nacos?hmsr=aladdin1e1	
			区别
				http://www.qishunwang.net/news_show_20689.aspx		
				https://www.cnblogs.com/aixing/p/13327127.html
				https://zhuanlan.zhihu.com/p/165217227
				https://www.cnblogs.com/youyouxiaosheng-lh/p/11209421.html
				https://blog.csdn.net/fly910905/article/details/100023415
				https://blog.csdn.net/weixin_42496542/article/details/109241719
		},
		vs：{
			Nacos与Eureka区别:最大区别：Nacos支持两种模式CP/Ap模式，从Nacos 1.0 版本开始，注意模式就是Ap模式
			
			大多的注册中心都是AP

			Nacos对比Zookeeper、Eureka之间的区别
			从相同点、不同点、中心化思想三方面来
			三者都可以实现分布式注册中心框架.
			不同点：
			Zookeeper采用CP保证数据的一致性的问题， 原理采用(ZAP原子广播协议) ， 当我们ZK领导者因为某种情况下部分节点出现了故障，会自动重新实现选举新的领导角色，整个选举的过程中为了保证数据一致性的问题， 客户端暂时无法使用我们的Zookeeper， 那么这意味着整个微服务无法实现通讯（本地有缓存除外）。
			注意：可运行的节点必须满足过半机制，整个zk采用使用，自己选举 leader 和 处理follower 

			Eureka采用AP设计思想实现分布式注册中心， 完全去中心化、每个节点都是相等， 采用你中有我、我中有你相互注册设计思想，只要最后有一台Eureka节点存在整个微服务就可以实现通讯。

			中心化：必须围绕一个领导角色作为核心，选举领导和跟随者角色。
			去中心化：每个角色都是均等。

			我们在使用注册中心，可用性优先级最高，可以读取数据短暂不一致性，但是至少要能够保证注册中心可用性。

			Nacos从1.0版本选择AP和CP混合形式实现注册中心， 默认情况下采用AP， CP则采用Raft协议实现保持数据的一致性。
			如果选择为AP模式，注册服务的实例仅支持临时模式，在网络分区的的情况允许注册服务实例，选择CP模式可以支持注册服务的实例为持久模式，在网络分区的产生了抖动情况下不允许注册服务实例。
		}
	}
}



61-linux:{
	105-os-env:{	"环境变量"	
		des:{
			 '简要的说，就是指定一个目录，运行软件的时候，相关的程序将会按照该目录寻找相关文件。''设置变量对于一般人最实用的功能就是：不用拷贝某些dll文件到系统目录中了，而path这一系统变量就是系统搜索dll文件的一系列路径。'
		? ? '在linux系统下，如果你下载并安装了应用程序，很有可能在键入它的名称时出现“command not found”的提示内容。如果每次都到安装目标文件夹内，找到可执行文件来进行操作就太繁琐了。这涉及到环境变量?PATH?的设置问题，而?PATH的设置也是在linux下定制环境变量的一个组成部分。linux 查看环境变量与设置环境变量在使用过程中很常见，本文整理了一些常用的与环境变量相关的命令。'
		},
		set/unset/readonly :{
			/etc/profile			'所有用户-永久'		eg.:{	# vi  /etc/profile 				export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib }		# source /etc/profile
			$HOME/.bash_profile		'单一用户-永久'		eg.:{	# vi  /home/guok/.bash.profile 	export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib }		$ source /home/guok/.bash_profile		$HOME/.bashrc
			export					'当前sh	 -临时'		eg.:{	$ export HELLO="Hello!" }		'只在当前的shell(BASH)或其子shell(BASH)下是有效的，shell关闭了，变量也就失效了，再打开新shell时就没有这个变量，需要使用的话还需要重新定义'
			$ unset $TEST 
			$ readonly TEST
		}
		see:{
			$ echo $HELLO	/	echo $JAVA_HOME 
			$ env	'所有的环境变量'			$ env|grep TEST
			$ set	'所有本地定义的Shell变量'
			type -a SHELL_NAME
			
		},
		order:{
			1. 绝对命令 '指定目录',
			2. alias 别名,
			3. 内置命令:{
				'由SHELL解释器（Bash）来判断用户输入的是内部命令还是外部命令'
				内部命令: '所谓的是解释器内部的指令（在启动时就调入内存的，执行效率高），会被直接的执行，而绝大部分的时候都会是外部命令（系统的软件功能，用户需要时才从硬盘调入内存的），交由给第四步骤来继续处理，当然您还可以使用“type 命令名称”来手工判断是内部命令还是外部命令，也是很有趣的'
			},			
			4. env-path:{
				/etc/profile	->		/etc/bashrc						->		~/.profile，												->		~/.bashrc
				/etc/profile	->	/etc/profile.d和/etc/inputrc 		->		~/.bash_profile	->	~/.bash_login	->	~/.profile			->		~/.bashrc
			}
		}
	}
}